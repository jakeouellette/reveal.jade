extends ./layout.jade

block slides
  // Intro
  section
    p Jake Ouellette @Jakeout
    img(src='resources/twitter_logo.png', height='200', class='noborder')
  section
    div.fragment.dimafter
      h1 I heard you like Plugins
    h2.fragment(data-autoslide=0) Architecting plugins for extensibility
    +notes.
      I'm Jake Ouellette, software engineer at Twitter, this is my talk.
      Add this is a talk about extensibility
  section
    p.fragment plugins ?
    +notes
      ul
        li talk about plugin development
        li wanted talk focused on extensibility
        li plugins are the architectural detail of how we extend gradle
        li obstensibly, had to write a talk about plugins
      p that said, is a talk about good SE
      p please learn broadly
  section
    p my perspectives
    +notes
      p I've done a lot of Gradle plugin development.
      p Last year I gave a similar talk to this
      p and it motivated me to change a bunch of things
      p in our plugins. point out my flaws
  section
    p fabric
    img(src='resources/fabric_logo.png', height='300', class='noborder')
    +notes
      p What have I built?  I work at Twitter, on Twitter's Mobile platform, fabric. 
      p Fabric is a suite of Mobile SDKs which developers use to enhance their application
      p One example build tool is Crashlytics.
  section
    p crashlytics
    img(src='resources/crashlytics_logo.png', height='300', class='noborder')
    +notes.
      Crashes as a service.
  section
    p crashes-as-a-service
    img(src='resources/fabric_app.png', height='800', class='noborder')
  section
    // TODO: land on first fragment automatically
    p.fragment.dimafter foo()
    p.fragment.dimafter a()
    p.fragment foo()
    +notes.
      When you compile your app, you might have a method foo
      But when it gets compiled, a tool called proguard converts it into 'a'
      There's a file during your build which says "a() -&gt; foo()"
      We send these files to our backend and allow you to inspect your crashes
  section
    img(src='resources/crashlytics_logo.png', height='300', class='noborder')
    p A gradle plugin
    +notes.
      so all of this is a gradle plugin built on top of the android plugin for gradle
  section
    img(src='resources/android_robot.png', height='300', class='noborder')
    p integrates with android
  section
    h2 overview
    ul
      li.fragment.dimafter teach you about extensible software
      li.fragment.dimafter contrast gradle to other tools
      li.fragment focus on extensibility within gradle
    +notes
      p OK, so what is this talk about:
  // End of introduction
  // Problem statement, defining extensibility
  section
    p let's pretend you're a software engineer
    p.fragment Senior Jawa Developer
    // TODO: jawa picture
    +notes.
      Let's pretend you're a software engineer
      Let's say I have a mythical language called Jawa,
  section
    p.fragment.dimafter new build!
    p.fragment apply plugin: 'jawa'
    +notes.
      and And so you get excited, and start a new gradle build
  section
    p.fragment.dimafter now you hook it up to ci & translation service
    p.fragment apply plugin: 'ci-3po'
    +notes.
      now you hook it up to be uploaded to a ci & translation service
  section
    p.fragment.dimafter awesome. 
    p.fragment.dimafter You hook up a plugin that converts resources into d3 visualizations in jawa
    p.fragment apply plugin: 'r2d3'
  section
    p.fragment.dimafter BUILD FAILED
    p.fragment oh dear
    +notes.
      It turns out, r-2-d3 and ci-3po were both messing with your resources.
      you see, ci-3po is an unextensible plugin that is also translating
      your resources for your jawa app as you build.
  section
    p so now you're stuck.
    div.fragment
      img.noborder(src='resources/r2po.png')
      em source: http://celebrityskinned.com/
    +notes.
      you have to pick one of the two tools, or try
      to hack them apart
  section
    p extensibility is a spectrum
    p.fragment has 2 sides, light and dark
    +notes.
      Extensibility is a spectrum.
      You can go all in on extensibility, or you can make
      it impossible for others to play in your walled garden
  // How can we recognize extensibility is?
  section
    p.fragment.dimafter Unextensible: ci-3po + other plugins = impossible
    p.fragment.dimafter More Extensible: ci-3po + other plugins = feasible
    p.fragment Most extensible: ci-3po's components separable
  section
    p be selfish
    p.fragment.replaceafter extensibility
    p.fragment.replaceafter high cohesion
    p.fragment.replaceafter easy-to-extend with mocks
    p.fragment.replaceafter easy-to-reuse elsewhere
    p.fragment easy-to-understand
    p.fragment
      p.fragment.replaceafter
        img.noborder(src='resources/xkcd_star_wars.png', width='900')
        em source: http://xkcd.com/657/
      p.fragment
        img.noborder(src='resources/xkcd_primer.png', width='900')
        em source: http://xkcd.com/657/
    +notes
      p star wars may seem complicated,
      p but really, it has many characters that
      p come together occasionally, and then have their own story
      p compared to primer, with very few characters, is nearly incomprehensible
      p a movie, about time travel
  section
    p.fragment.dimafter Extensible Software in Two Steps:
    ol
      li.fragment.dimafter Build many layers
      li.fragment Each layer only solves its own problems
    +notes.
      The first step in this may not be possible if business requirements prevent
      you. E.g., maybe you need to tightly couple translation to CI uploads,
      but there's no reason to couple it to compilation.
  section
    p modularity.jawa ?
    +notes.
      You'll notice I'm not advocating a modularity system to you to achieve extensibility
      OSGi, Java 9, j2ee WARs, Android services
  section
    p To learn how to build extensible Gradle plugins,
    p you must first learn to how program.
  section
    p what do advocates recommend?
  section
    p SOLID-OO
    p 
      em Martin Fowler
    ul.fragment
      li.fragment.dimafter Single Responsibility 
      li.fragment.dimafter Open/Closed
      li.fragment.dimafter Liskov Substitution
      li.fragment.dimafter Interface Segregation
      li.fragment Dependency Inversion
    +notes.
      Martin fowler, prominent OO proponent
      the solid princples are
  section
    p not the only advocate
  section
    p unextensible code is unmockable
    +notes.
      you see, it's hard to write tests if your code is unextensible
  section
    p Google Testability Team Testable Software Principles
    p 
      em Jonathan Wolter, Russ Ruffer, Mi≈°ko Hevery
    ul.fragment
      li.fragment.dimafter Class does too much
      li.fragment.dimafter Reaching into collaborators
      li.fragment.dimafter Has Singletons
      li.fragment Constructors do real work
    +notes.
  section
    h2 Holub on Patterns
    p 
      em Allen Holub
    ul.fragment
      li.fragment.dimafter Extends is evil
      li.fragment.dimafter Getters and Setters are evil
    p
      img.fragment(src='resources/emperor_palpatine.gif', height='300', class='noborder')
    +notes.
      Allen holub promonent JavaWorld, Dr. Dobbs
      Consultant
  section
    p good code
    +notes.
      All these share characteristics, some are
      guidelines to avoid, some are guidelines to do
  section
    p examples
    +notes.
      I am going to argue there are 2 core Principles
      by which all others can be derived, let's understand
      what makes code inflexible through example.
  section
    +codeexample
      p
        | class R2D3 {
        |   public visualize() {
        |     ...
        |   }
        | }
    +notes.
      Let's talk about R2D3.
      We said it visualizes resources using d3
      a javascript framework
  section
    +codeexample
      p
        | class R2D3 {
        | 
        +codeblock
          |   public visualize(String projectRoot) {
          |     List&lt;File&gt; resources = getResources(projectRoot)
          |     // Visualizer code
          |   }
        | 
        +codeblock
          |   public List&lt;File&gt; getResources(String projectRoot) {
        |     ...
        |   }
        | }
    div.fragment 
      p
        em multiple-responsibility
    +notes
      p so this visualize task
      p calls this getResources method
  section
    p what if I extend the thing
    +codeexample
      | class R2D3 extends FileFinder {
      | 
      +codeblock
        |   public visualize(String projectRoot) {
        |     List&lt;File&gt; resources = getResources(projectRoot)
        |     // Visualizer code
      |   }
      | }
    div.fragment 
      p
        em multiple-responsibility through 
      p 
        em extends
    +notes.
      the problem is this method is tightly coupled
      to this class's implementation of get resources
  section
    p ok i'll do it earlier
    +codeexample
      p
        | class R2D3 {
        |   List&lt;File&gt; files;
        | 
        +codeblock
          |   R2d3(String projectRoot) {
          |     ResourceService finder = new FileFinder(projectRoot)
          |     files = finder.getResources()
          |   }
        | 
        |   public visualize() {
        |     ...
        |   }
        | }
    div.fragment 
      p
        em multiple-responsibility through 
      p 
        em constructor coupling
    +notes
      p OK, we can extract FileFinder out
      p create it ahead of time in our constructor
  section
    h2 avoid new in constructors
    p.fragment dependency inversion
    +notes.
      // TODO: motivate
  section
    p ok, no new in my constructor!!!1
    +codeexample
      p
        | class R2D3 {
        |   List&lt;File&gt; files;
        | 
        +codeblock
          |   R2d3(String projectRoot) {
          |     files = FileFinder.getResources(projectRoot)
          |   }
        | }
    div.fragment 
      p
        em multiple-responsibility through 
      p 
        em Singleton / global coupling
    +notes.
      OK
  section
    p hey I fixed it
    +codeexample
      | class R2D3 {
      |   List&lt;File&gt; files;
      | 
      +codeblock
        |   public visualize(String projectRoot) {
        |     FileFinder finder = new FileFinder(projectRoot)
      |     files = finder.getResources(projectRoot)
      |     // Visualizer code
      |   }
      | }
    div.fragment 
      p no, you didn't!
      p
        em multiple-responsibility
      p
        em ... coupling just delayed
      +notes.
        Fine, move it out of the constructor!!
        NOPE! still coupled.
  section
    p good code
    +codeexample
      | class R2D3 {
      |   final &lt;File&gt; files;
      | 
      +codeblock
        |   R2d3(&lt;File&gt; visualizableFiles) {
        |     this.files = visualizableFiles;
        |   }
      | 
      +codeblock
        |   public visualize() {
        |     // visualization code
        |   }
      | }
    +notes.
      A good pattern is to separate
      out the concerns and JUST pass in the files
      you might also inject it into the
      visualize method depending on how it works
  section
    p so that's 'single responsibility'
  section
    p Ci3po: the translator
    +codeexample
      | class Ci3po {
      |   ...
      |   public translate() {
      |     ...
      |   }
      | }
  section
    +codeexample
      | class Ci3po {
      |   ...
      |   public translate(TaskContainer t) {
      |     List&lt;File&gt; files = t.getByPath(:app:fileFinder").fileFinder.getResources();
      |     ...
      |   }
      | }
    div.fragment 
      p
        em tightly coupled inputs
    +notes.
      This is tightly coupled, to mock it:
  section
    +codeexample
      |   def collaborator() {
      +codeblock
        |     Ci3po.translate(new TaskContainer() {
        |       public getByPath(String s) {
        |         return resourceService
        |       }
        |       ... (40 more lines of code)
        |     })
      |   }
      | }
  section
    +codeexample
      |   def collaborator() {
      +codeblock
        |     Ci3po.translate(resourceService.getResources())
      |   }
      | }
  section
    +codeexample
      | interface ResourceService
      |   public List&lt;File&gt; getResources()
    div.fragment
      +codeexample
        | class FileFinder
        |   public List&lt;File&gt; getResources() {
        |   ...
        |   public void deleteFiles() {
        |   ...
    +notes
      p Let's assume you've got a interface, resource service
      p and a class that implements it
      p maybe that class has a lot of other methods
      p that are weird
  section
    +codeexample
      | class Ci3po {
      |   ...
      |   public translate(FileFinder f) {
      |     List&lt;File&gt; = f.getResources()
      |     ...
      |   }
      | }
    div.fragment 
      p
        em tightly coupled inputs through
      p
        em overly specific implementation
    +notes.
      Now I'm locked into creating a FileFinder,
      if it has a lot of extra scope, I don't
      want to have to build that state.
      Let me pass in what you'll use!
  section
    +codeexample
      | interface ResourceService
      |   public List&lt;File&gt; getResources()
    p vs
    div.fragment
      +codeexample
        | interface ResourceService
        |   public List&lt;File&gt; getResources()
        |   public void delete()
        |   public File find(String path)
    +notes.
      if a class doesn't need elements of an interface
        let's not make it mroe complex because of them
  section
    p YAGNI
  section
    +codeexample
      | class Ci3po {
      |   ...
      |   public translate(ResourceService f) {
      +codeblock
        |     if (f instanceof FileFinder) {
      |       List&lt;File&gt; files = (FileFinder) f.getResources()
      |       ...
      |     }
      |   }
      | }
    div.fragment 
      p
        em tightly coupled inputs through
      p
        em closed for extension code
    +notes.
      I'm STILL locked into creating a FileFinder,
      because you are using instanceof
  section
    p 717 cases of instanceof in gradle github repo
    +notes.
      not necessarily bad, but can be
      If you're checking more than once instanceof,
      adding a new one requires changing the code
      instead, ask services to do things for you
  section
    h2 instanceof only immutable datatypes
    p.fragment further reading: scala case classes
    // TODO: add matcher here
    // TODO: fully grep this
    +notes.
      because: if its not immutable data, can ask it to solve problem
      for you.
  section
    p Ci3po: Translations as a service
    +codeexample
      | class Ci3po {
      | 
      +codeblock
        |   Uploader uploader;
      | 
      |   public translate(ResourceService f) {
      |     ...
      |   }
      | }
    +notes.
      Ok, now let's say Ci3po has a translator it uses
  section
    +codeexample
      | class Ci3po {
      | 
      |   Uploader uploader;
      | 
      |   public translate(ResourceService f) {
      +codeblock
        |     uploader.setEndpoint('http://ci/translations')
        |     uploader.sendGet(
        |        new HttpGet('hasTranslations', 
        |        params(f.getFiles()))
      |     ...
      |   }
      | }
    div.fragment 
      p
        em tightly coupled inputs through
      p
        em reaching into state
    +notes.
      Translator calls into an uploader, instead of asking it
      if it has translations, it makes a request, coupling to httpclient
  section
    p better
    +codeexample
      | class Ci3po {
      | 
      |   Uploader uploader;
      | 
      |   public translate(ResourceService f) {
      +codeblock
        |     boolean hasTranslations = uploader.hasTranslations(f.getFiles())
      |     ...
      |   }
      | }
  section
    p demand-side problem:
    +codeexample
      | class YourResourceService extends ResourceService
      |   public delete() {
      |     throw new UnsupportedOperationException("nooo!")
      |   }
      |   ...
    div.fragment
      p
        em tight coupled inputs through
      p
        em extreme liskov substitution
    +notes
      p What if I wrap Ci3po, but take in your resource
      p service? If you don't implement apis
      p and I think I have to call them, will break things
  section
    h2 Core Principles
    ol
      li.fragment Classes should have a single responsibility
      li.fragment Classes should not have visibility into scope they don't need.
  // End general software engineering extensibility
  section
    p Apply some of these principles to existing build tools
    ul.fragment
      li Ant
      li Maven
      li Gradle
    +notes.
      Others
      Grunt, Gulp, WebPack bazel, rake, leinengen
  section
    p.fragment ant
    +codeexample.fragment
      | &lt;project&gt;
      |  
      |   &lt;target name="clean"&gt;
      |     &lt;delete dir="build"/&gt;
      |   &lt;/target&gt;
      | 
      +codeblock 
        |   &lt;target name="compile" dependsOn="clean"&gt;
        |     &lt;mkdir dir="build/classes"/&gt;
        |     &lt;javac srcdir="src" destdir="build/classes"/&gt;
      |   &lt;/target&gt;
    +notes.
      Ant's composability model is vastly different from gradle
      Tasks depend on other tasks, similar to gradle
  section
    +codeexample
      |   &lt;target name="compile" dependsOn="clean"&gt;
      +codeblock 
        |     &lt;mkdir dir="${build.classes}"/&gt;
      |     &lt;javac srcdir="src" destdir="build/classes"/&gt;
      |   &lt;/target&gt;
    +notes.
      you can replace folders with variables and get "injected"
      behaviors, but because it's all just XML, it's hard to follow
      no patterns or idioms
  section
    div.fragment
      img.noborder(src='resources/r2po.png')
    +notes.
      in ivy, if you have two things conflicting,
      you'd manually have to edit both of their build.xmls,
      but it's up to the ofter to allow parameter overloading
      and APIs are not transparent
  section
    p ant: no dependency management
    p.fragment.replaceafter ant: decoupled dependency management
  section
    p ivy: decoupled from ant
    +codeexample
     | &lt;ivy-module version="2.0"&gt;
     | &lt;dependencies&gt;
     |   &lt;dependency org="commons-lang" name="commons-lang" rev="2.0"/&gt;
  section
    p decoupled=reusable
    p.fragment android gradle support on eclipse not sufficient
  section
    p so we grabbed Ivy
    p.fragment (demo)
  section
    p maven
  section
    p In maven, tasks are tightly coupled to 'the maven way'
  section
    p validate
    p.fragment.unhide(data-fragment-index='1').highlight-green androidGenerateResources
    p.fragment.unhide(data-fragment-index='3').highlight-red crashlyticsGenerateResources
    p.fragment.unhide(data-fragment-index='2').highlight-green androidMergeResources
    p compile
    p test
    p package
    p integration-test
    p verify
    p install
    p deploy
    +notes.
      I mentioned this in my talk last year, and since
      Tasks work differently in maven
      Maven declares several phases, and you can have your task run as one of them, 
      if your plugin behavior should run between two tasks of another plugin in a phase, 
      you‚Äôre out of luck!
  section
    p maven-inherit-plugin
    +codeexample.fragment
      | /**
      |  * @extendsPlugin eclipse
      |  * @goal eclipse
      |  * @phase package
      |  */
    p.fragment
      em Coupling through inheritance :(
    +notes.
      I've discovered the maven-inherit plugin, but the way
      it works is your plugin inherits, it depends on another plugin
      breaking composability
      Maven's rigidity makes easy things easy and hard things
      nearly impossible
      Parallelism also impacted
  section
    p in maven, configuration of a project exists as XML
    +codeexample
      | &lt;configuration&gt;
      |   &lt;renameManifestPackage&gt;com.jakeout.app.free&lt;/renameManifestPackage&gt;
    +notes.
    So the android maven plugin let you rename the package of the project
  section
    p.fragment.replaceafter com.jakeout.app
    p.fragment.replaceafter com.jakeout.app.free
    +notes.
      So for example, if on maven
      someone has a free version of an app, they might rename it
  section
    p gradle would be groovy code
    p.fragment it's just XML
    p.fragment so you can parse it right?
  section
    p wrong!
    div.fragment
      p variable resolution 
      p ${app-flavor}
  section
    p plugins can get this state
    p.fragment.dimafter getPluginByKey(ANDROID_MAVEN_PLUGIN)
    p.fragment.dimafter (Xpp3Dom) plugin.getConfiguration()
    p.fragment.dimafter extractConfigValueFrom(config, "renameManifestPackage")
    +notes.
      plugins get this state through calls to the maven APIs
  section
    p Other tooling can't read it
  section
    p enter maven aether
    +notes.
      maven has a solution for this, though I've never used it
      it's called aether: http://www.eclipse.org/aether/
      and it lets you run just the variable resolution
      Even though maven seems like it's just configuration,
      it has the same tight coupling that gradle does
  section
    p similar gradle problem
    +codeexample
      |   plugin {
      |     id "com.trello.victor" version "0.1.4"
      |   }
    +notes.
      It brings to mind gradle's new plugin { } block
      so a friend of mine has a plugin that converts
      resources SVGs on android
      but the plugin block is rigid, it's a restricted DSL,
      it must not execute code.
  section
    +codeexample
      |   plugin {
      |     id "com.trello.victor" version "0.1.5-SNAPSHOT"
      |   }
     +notes.
       if he wanted to test against this dynamically, he couldnt
  section
    +codeexample
      |   plugin {
      |     id "com.trello.victor" version "$version"
      |   }
    p
      em not possible
    +notes.
      One of the reasons this was likely made impossible is
      so that tools can more easily inject into these files
  section
    p if you need parsable artifacts:
    p.fragment.dimafter avoid groovy code
    p.fragment.dimafter properties files
    p.fragment.dimafter manifests
    +notes
      p if you need external tooling to parse the artifact
      p avoid groovy code
  section
    +codeexample
      |   dependencies {
      |     classpath 'com.android.tools.build:gradle:1.2.3'
      |   }
    +notes.
      besides, I'd argue that the classpath block
      needs the ability to modify
      with automated tooling even more.
  section
    p fabric onboarding demo
  section
    p so we can onboard fabric,
    p added lines to your build.gradle
    +notes.
      p and suddenly, it expands from 100 lines to 1000 lines
  section
    p plugins and extensibility
  section
    p.fragment.replaceafter a little declarative code
    p.fragment.replaceafter descriptions
    p.fragment 'what'
    p.fragment.replaceafter mostly imperative code
    p.fragment.replaceafter directions
    p.fragment 'how'
    +notes
      p realize most of your build build is imperative code
  section
    p.fragment.replaceafter 1000 lines of code
    p.fragment 1 apply plugin
  section
    p plugin adds
    p.fragment.replaceafter higher level models
    p.fragment 'cleaner what'
    p.fragment.replaceafter new tasks
    p.fragment 'how'
  section
    p models
    p.fragment.replaceafter android { }
    p.fragment.replaceafter java { }
    p.fragment.replaceafter maven { }
    p.fragment.replaceafter osgi { }
    +notes.
      model building allows you to add new
      properties to the build, better describing
      what you have, and what you want
  // TODO: example of bad model extension in Gradle
  section
    p Building on top of other plugins:
    p Decouple plugin behavior from inter-plugin seams
  section
    p default user build script
    pre.fragment
      p android.runProguard = true
    p.fragment BUILD SUCCESSFUL
  section
    p our plugin
    pre.fragment
      | if (buildType.runProguard) {
      |   // mapping file upload
      |   
    p.fragment BUILD SUCCESSFUL
  section
    p Android Gradle 1.0
    p.fragment.replaceafter android.runProguard
    p.fragment android.minifyEnabled
  section
    p default user build script
    pre.fragment
      p android.runProguard = true
    p.fragment BUILD SUCCESSFUL
  section
    p our plugin
    pre.fragment
      | if (buildType.runProguard)
      |   // mapping file upload
      |   
    p.fragment BUILD FAILED
    +notes.
      The problem is, they had made a property that was write only,
      it mapped to an underlying property. They didn't break user's
      builds, unless user's cared about proguard
  section
    p necessarily unsolvable
  section
    p abstract away model inputs:
    +codeexample
      | if (buildType.hasProperty('minifyEnabled')) {
      |   proguardEnabled = buildType.minifyEnabled
      | } else if (buildType.hasProperty('runProguard')) {
      |   proguardEnabled = buildType.runProguard
      | }
    div.fragment
      p
        em pass proguardEnabled forward as internal state
    +notes.
      you can expose this as a model object on your extensions
  section
    p.fragment fabric { proguardEnabled = null }
  section
    p.fragment fabric { proguardEnabled = android.minifyEnabled }
  section
    p.fragment project.extensions.create('fabric', FabricExtension)
  section
    +codeexample
      | if (buildType.hasProperty('minifyEnabled')) {
      |   proguardEnabled = buildType.minifyEnabled
      | } else if (buildType.hasProperty('runProguard')) {
      |   proguardEnabled = buildType.runProguard
      +codeblock
        | } else if (fabric.proguardEnabled != null) {
        |   proguardEnabled = fabric.proguardEnabled
      | }
    +notes.
      added to check, our state
  section
    p gradle tasks and extensibility
  section
    p generateResourcesTask.dependsOn('dex${suffix}')
  section
    +codeexample
      | apply plugin('com.android.application')
    +notes.
      most people get proguard obfuscation through applying the android plugin
  section
    +codeexample
      | apply plugin('dexguard')
    +notes.
      There's a paid version of proguard that is available by applying this
  section
    p.fragment.dimafter foo()
    p.fragment.dimafter Êº¢()
    p.fragment foo()
  section
    +codeexample
      | apply plugin('dexguard')
    p.fragment BUILD FAILED
  section
    +codeexample
      |    def obfuscationTask
      |    if (project.getPlugins().hasPlugin('dexguard')) {
      |        obfuscationTask = "dexguard"
      |    } else {
      |        obfuscationTask = "dex"
      |    }
    div.fragment
      p
        em pass obfuscationTask forward as internal state
    +notes.
      extract out the task name early in your process,
      you can expose this as a model object
  section
    p.fragment fabric { obfuscationTask = null }
  section
    p.fragment fabric { obfuscationTask = "dexguard" }
  section
    p 'java' plugin
    p jar { } task
  section
    p 'fatjar' plugin
    p fatjar { } task
    p.fragment.replaceafter 'This is regular Jar task'
    p.fragment Note: regular jar and war tasks are not replaced by this plugin.
    p
      pre.fragment
        | project.tasks.create(FATJAR_FAT_JAR, Jar)
    p.fragment.replaceafter
      em tightly coupled to the jar task
    p.fragment
      em can't be composed with alternative jar task extensions
    p.fragment
      em other plugins override original jar task config
  section
    p solutions:
    ul
      li.fragment allow jar to be injected
      li.fragment fatten before the jar task
    +notes.
      dependency injection, single responsibility remove this coupling 
  section
    +codeexample
      |  def apply(Project project) {
      |    project.task('uploadTranslations') {
      |      ext.file = ...
      |    } &lt;&lt; {
      +codeblock
        |      HttpRequest r = new HttpRequest(url)
      |      ...
      |    }
    p.fragment
      em task behavior coupled to instance of a task
  section
    +codeexample
      |  // ci-3po
      |  def apply(Project project) {
      |    project.task('uploadTranslations') {
      |      ext.file = ...
      |    } &lt;&lt; {
      +codeblock
        |      translationUploader.upload(ext.file)
      |    }
  section
    +codeexample
      | class UploadTask extends DefaultTask {
      |   @TaskAction
      |    def upload() {
      +codeblock
        |      HttpRequest r = new HttpRequest(url)
      |      ...
      |    }
      |    String url
      |    String file
    +notes.
      You could, of course, override DefaultTask
      However, it uses extends, and setters, and
      so couples behavior to task execution
  section
    +codeexample
      | class UploadTask extends DefaultTask {
      |   @TaskAction
      |    def upload() {
      +codeblock
        |      new TranslationUploader(url).upload(file)
      |    }
      |    String url
      |    String file
    +notes.
      An easy solution is to treat tasks as behavior factories:
      separate the responsibility of being a task from
      the behavior creation
  section
    +codeexample
      | class TranslationUploader {
      |   private final String url;
      |   
      |   public TranslationUploader(String url) {
      |     this.url = url;
      |   }
      |   public upload(File f) {
      |     ...
    p
      em Parameters are explicit and immutable
    +notes.
      now you've decoupled translation from gradle
  section
    p extensibility: avoid mutability
  section
    p.fragment.dimafter foo()
    p.fragment.dimafter a()
    p.fragment foo()
  section
    p your mapping file has an identifier
    p
      em UUID: a() -&gt; foo()
  section
    p your crash has that identifier
    p
      em UUID: crash at a()
  section
    p Therefore:
    p We need an identifier in your app
  section
    +codeexample
      | &lt;string name="com.crashlytics.android.build_id" 
      |   translatable="false"&gt;
      | 
      |   c69eaf36-ded8-4a75-8719-346d33193e9d
      | 
      | &lt;/string&gt;
  section
    p Implementation:
    p Generate a new id when build starts
  section
    p.fragment fabric plugin generates an id
    p.fragment android plugin uses an id
  section
    p multiple variants
    p free / paid
    p.fragment fabric plugin generates the #[span(style="color:blue;") id]
    p.fragment free uses the #[span(style="color:blue;") id]
    p.fragment(style="color:red;") paid uses the same #[span(style="color:blue;") id]
  section
    p Implementation:
    p Generate a new id when variant build starts
  section
    p multiple variants (e.g., free / paid)
    p.fragment fabric plugin generates #[span(style="color:blue;") id1]
    p.fragment free uses #[span(style="color:blue;") id1]
    p.fragment fabric plugin generates #[span(style="color:green;") id2]
    p.fragment paid uses #[span(style="color:green;") id2]
  section
    p parallel builds variants
    p.fragment fabric plugin generates #[span(style="color:blue;") id1]
    p.fragment fabric plugin generates #[span(style="color:green;") id2]
    p.fragment(style="color:red;") free uses #[span(style="color:green;") id2]
    p.fragment paid uses #[span(style="color:green;") id2]
  section
    p what we want
    p.fragment fabric plugin generates #[span(style="color:blue;") id1]
    p.fragment fabric plugin generates #[span(style="color:green;") id2]
    p.fragment free uses #[span(style="color:blue;") id1]
    p.fragment paid uses #[span(style="color:green;") id2]
  section
    p Implementation:
    p Generate a variant-specific input
  section
    p.leftalign class MergeResourcesTask {
    p.leftalign @InputDirectory
    p
    p 'build/intermediates/res/values/'
    p
    p.fragment 'build/intermediates/res/values/build_id.xml'
  section
    p Android Model DSL
    p android.variant.resValue = c69eaf36-ded8-4a75-8719-346d33193e9d
    +notes.
      super elegant
  section
    +codeexample
      | &lt;string name="com.crashlytics.android.build_id" 
      | 
      |   c69eaf36-ded8-4a75-8719-346d33193e9d
      | 
      | &lt;/string&gt;
    p.fragment
      no translatable="false"
    p.fragment
      em LINT FAILURE
  section
    p android.variant.resValue coupled to specific use case
  section
    p Android Model DSL #2
    p variant.registerResGeneratingTask(task, generatedResFolders)
  section
    p Correct abstractions facilitate users
  section
    p one more thing
  section
    p a build's output
    p.fragment function of:
    ul
      li.fragment.dimafter What your project is
      li.fragment.dimafter What you want
      li.fragment.dimafter Your local disk cache
      li.fragment.dimafter The Internet
      li.fragment Tools
        ul
          li.fragment.dimafter Extensions to tools
  section
    p finding bugs can be hard
    p.fragment UP-TO-DATE
    +notes.
      part of a pretty complicated system
  section
    p ./gradlew assemble --debug
    +notes.
      so you do a debug build
  section
    img(src='resources/programming.gif', height='400', class='noborder')
    +notes.
      good choice.
  section(data-background="resources/bbmachine.gif" data-background-size="500px" data-background-repeat="repeat")
    +notes.
      have you ever looked at a --debug build?
      hard to parse   
  section
    p Inspector
    p
      img(src='resources/gadget.gif', height='400', class='noborder')
    +notes.
      this plugin is not intended to be turned on
      all the time, this plugin is designed for the use case
      of "There's something wrong with my build",
      I need help
  section
    p demo
  section
    p conclusion
    ul
      li.fragment Extensibility is good
      li.fragment Gradle's model is evolving
      li.fragment Lots of opportunities for better designs
  section
    p Jake Ouellette @Jakeout
    img(src='resources/twitter_logo.png', height='300', class='noborder')
