<section><div class="fragment"><p>What leads to High Cohesion?</p></div></section><section><div class="fragment"><p>Using SOLID</p><p> <em>Martin Fowler</em></p><p><img src="resources/martin_fowler.jpg" class="noborder"/></p><ul><li class="fragment dimafter">Single Responsibility </li><li class="fragment dimafter">Open/Closed</li><li class="fragment dimafter">Liskov Substitution</li><li class="fragment dimafter">Interface Segregation</li><li class="fragment">Dependency Inversion</li></ul><aside class="notes">Martin fowler, prominent OO proponent
the solid princples are</aside></div></section><section><div class="fragment"><p>not the only advocate</p></div></section><section><div class="fragment"><p>tightly coupled code is unmockable</p><aside class="notes">you see, it's hard to write unit tests if your code is uncohesive</aside></div></section><section><div class="fragment"><p>Google Testability Team Testable Software Principles</p><img src="resources/misko.jpg" class="noborder"/><p> <em>Jonathan Wolter, Russ Ruffer, Mi≈°ko Hevery</em></p><ul><li class="fragment dimafter">Class does too much</li><li class="fragment dimafter">Reaching into collaborators</li><li class="fragment dimafter">Has Singletons</li><li class="fragment">Constructors do real work</li></ul><aside class="notes"></aside></div></section><section><div class="fragment"><h2>Holub on Patterns</h2><p> <em>Allen Holub</em></p><p><img src="resources/allen_holub.jpg" class="noborder"/></p><ul><li class="fragment dimafter">Extends is evil</li><li class="fragment dimafter">Getters and Setters are evil</li></ul><aside class="notes">Allen holub promonent JavaWorld, Dr. Dobbs
Consultant</aside></div></section><section><div class="fragment"><h2>All just different angles on same ideas:</h2><ol><li class="fragment">Understand the Difference between Data and Objects</li><li class="fragment">Objects should have a single responsibility</li><li class="fragment">Objects can't see what they don't need</li></ol><aside class="notes">Can derive e.g., SOLID principles from these.</aside></div></section><section><pre class="fragment dimcode"><p>class R2D3 {
  public visualize() {
    ...
  }
}</p></pre><aside class="notes">Let's talk about R2D3.
We said it visualizes resources using d3
a javascript framework</aside></section><section><pre class="fragment dimcode"><p>class R2D3 {
 <span class="fragment dimcode"><br/>  public visualize(String projectRoot) {
    List&lt;File&gt; resources = getResources(projectRoot)
    // Visualizer code
  }<br/></span> <span class="fragment dimcode"><br/>  private List&lt;File&gt; getResources(String projectRoot) {<br/></span>    ...
  }
}</p></pre><div class="fragment"> <p><em>multiple-responsibility</em></p></div><aside class="notes"><p>so this visualize task</p><p>calls this getResources method</p></aside></section><section><div class="fragment"><p>getResources is irreplacable, but irrelevant</p></div></section><section><div class="fragment"><p>Unmockable.</p></div></section><section><p>Testing requires knowledge of internals :(</p><pre class="fragment dimcode"> 
PowerMock.createPartialMock(R2D3.class, 
  "getResources").andReturn(files);
 </pre><aside class="notes">To change the behavior in unit test, you'd have to mock this get resources
method.</aside></section><section><div class="fragment"><p>Powermock requires looking at internals</p><img src="resources/c3po_naked.jpg" height="400" class="noborder"/><aside class="notes">a hidden collaborator</aside></div></section><section><div class="fragment"><p>Implies an iceberg</p><img src="resources/iceberg.jpg" height="400" class="noborder"/><aside class="notes">The need to powermock implies a tight coupling on internal behavior, not
a single responsibility
Not taking advantage of OO facilities to separate behaviors</aside></div></section><section><div class="fragment"><p>API exists, why not make it explicit?</p></div></section><section><p>what if I extend the thing</p><pre class="fragment dimcode"><span class="fragment dimcode"><br/>class R2D3 extends FileFinder {<br/></span> 
  public visualize(String projectRoot) {<span class="fragment dimcode"><br/>    List&lt;File&gt; resources = getResources(projectRoot)<br/></span>    // Visualizer code
  }
}</pre><div class="fragment"> <p><em>multiple-responsibility through </em></p><p> <em>extends</em></p></div><aside class="notes">the problem is this method is tightly coupled
to this class's implementation of get resources</aside></section><section><pre class="fragment dimcode"> 
PowerMock.createPartialMock(FileFinder.class, 
  "getResources").andReturn(files);
 </pre><aside class="notes">Still need to mock out the behavior in test, and
if that internal class references something mock-worthy, but it, itself, isnt,
then you get into tree-hierarchy searches that are complicated</aside></section><section><div class="fragment"><p>Hard to Swap</p><img src="resources/swap_board.gif" height="500" class="noborder"/><aside class="notes">hard to change behaviors, hard to swap out</aside></div></section><section><p>ok i'll do it earlier</p><pre class="fragment dimcode"><p>class R2D3 {
  List&lt;File&gt; files;
 <span class="fragment dimcode"><br/>  R2d3(String projectRoot) {<br/></span>    ResourceService finder = 
      new FileFinder(projectRoot)
    files = finder.getResources()
  }
 
  public visualize() {
    ...
  }
}</p></pre><div class="fragment"><p><em>multiple-responsibility through </em></p><p> <em>constructor coupling</em></p></div><aside class="notes"><p>OK, we can extract FileFinder out</p><p>create it ahead of time in our constructor</p></aside></section><section><p>Testing requires knowledge of internals :(</p><pre class="fragment dimcode"> 
expectNew(FileFinder.class, "projectRoot")
  .andReturn(files);
 </pre><aside class="notes">Now, in order to change the behavior you have to mock out internals.</aside></section><section><div class="fragment"><h2>avoid new in constructors</h2><p class="fragment">dependency inversion</p><aside class="notes">// TODO: motivate</aside></div></section><section><p>ok, no new in my constructor!!!1</p><pre class="fragment dimcode"><p>class R2D3 {
  List&lt;File&gt; files;
 
  R2d3(String projectRoot) {<span class="fragment dimcode"><br/>    files = FileFinder.getResources(projectRoot)<br/></span>  }
}</p></pre><div class="fragment"> <p><em>multiple-responsibility through </em></p><p> <em>Singleton / global coupling</em></p></div><aside class="notes">OK</aside></section><section><p>Testing requires knowledge of internals :(</p><pre class="fragment dimcode"> 
 PowerMock.mockStaticPartial(
   FileFinder.class, "getResources");
 EasyMock.expect(FileFinder.getResources(...))
   .andReturn(files);
 </pre><aside class="notes">Still mocking internals</aside></section><section><div class="fragment"><p>When do statics improve code?</p><p class="fragment dimafter">no this</p><p class="fragment dimafter">pure functions</p><p class="fragment dimafter">Still is coupling</p><aside class="notes">Avoid bleeding local scope. Handy for pure functions, good no intent to override</aside></div></section><section><pre class="fragment dimcode">class R2D4 extends R2D3 {
 
  @override
  public List&lt;File&gt; getResources()</pre><aside class="notes">One of the nice things about statics is they prevent inheritance
from being used to replace collaborator behaviors</aside></section><section><p>perfect code</p><pre class="fragment dimcode">class R2D3 {
  final List&lt;File&gt; files;
 <span class="fragment dimcode"><br/>  R2d3(List&lt;File&gt; visualizableFiles) {
    this.files = visualizableFiles;
  }<br/></span> <span class="fragment dimcode"><br/>  public visualize() {
    // visualization code
  }<br/></span>}</pre><aside class="notes">A good pattern is to separate
out the concerns and JUST pass in the files
you might also inject it into the
visualize method depending on how it works</aside></section><section><p>static factories are better than nothing</p><pre class="fragment dimcode"><p>class R2D3 {
  List&lt;File&gt; files;
 <span class="fragment dimcode"><br/>  public static R2D3 create(String projectRoot) {
    ResourceService finder = 
      new FileFinder(projectRoot)
    files = finder.getResources()
    return new R2D3(files)
  }<br/></span> <span class="fragment dimcode"><br/>  R2d3(List&lt;File&gt; visualizableFiles) {
    this.files = visualizableFiles;
  }<br/></span>  ...
}</p></pre><aside class="notes">You can make incremental refactorings that
get you closer to ideal. Better than passing
factories everywhere</aside></section><section><p>Static factory can be pulled out into a provider later.</p><pre class="fragment dimcode"><p>class R2D3Provider implements Provider&lt;R2D3&gt; {
  @Inject String projectRoot
 <span class="fragment dimcode"><br/>  public static R2D3 provide() {
    ResourceService finder = 
      new FileFinder(projectRoot)
    files = finder.getResources()
    return new R2D3(files)<br/></span>  }</p></pre></section><section><div class="fragment"><p>so that's 'single responsibility'</p></div></section><section><p>Ci3po: the translator</p><pre class="fragment dimcode">class Ci3po {
  ...
  public translate() {
    ...
  }
}</pre></section><section><pre class="fragment dimcode">class Ci3po {
  ...
  public translate(TaskContainer t) {<span class="fragment dimcode"><br/>    List&lt;File&gt; files = t
      .getByPath(:app:fileFinder")
      .fileFinder
      .getResources();<br/></span>    ...
  }
}</pre><div class="fragment"> <p><em>tightly coupled inputs</em></p></div><aside class="notes">This is tightly coupled, to mock it:</aside></section><section><div class="fragment"><p>Annoying to mock.</p></div></section><section><pre class="fragment dimcode">    Ci3po.translate(new TaskContainer() {<span class="fragment dimcode"><br/>      public getByPath(String s) {<br/></span>        return resourceService
      }<span class="fragment dimcode"><br/>      ... (40 more lines of code)<br/></span>    })</pre><aside class="notes">If we want to mock just the internal service, we have to
mock the full api, including the 40-some odd methods that are unused</aside></section><section><div class="fragment"><p>Easier: Just pass the right thing in!</p></div></section><section><pre class="fragment dimcode">    Ci3po.translate(resourceService.getResources())</pre></section><section><div class="fragment"><p>Single responsibility: Smaller interfaces</p><!-- TODO: better image--><img src="resources/confused_1.gif" height="500" class="noborder"/><aside class="notes">The cognitive load to understand mirrors the actual API usage</aside></div></section><section><pre class="fragment dimcode">interface ResourceService
  public List&lt;File&gt; getResources()</pre><p>vs</p><div class="fragment"><pre class="fragment dimcode">interface ResourceService
  public List&lt;File&gt; getResources()
  public void delete()
  public File find(String path)</pre></div><aside class="notes">if a class doesn't need elements of an interface
  let's not make it more complex because of them</aside></section><section><p>Inevitably:</p><pre class="fragment dimcode">class YourResourceService extends ResourceService
  public delete() {
    throw new UnsupportedOperationException("nooo!")
  }
  ...</pre><div class="fragment"><p><em>tight coupled inputs through</em></p><p><em>extreme liskov substitution</em></p></div></section><section><div class="fragment"><p>High cohesion: Avoid unneeded scope.</p></div></section><section><pre class="fragment dimcode">interface ResourceService
  public List&lt;File&gt; getResources()</pre><div class="fragment"><pre class="fragment dimcode">class FileFinder
  public List&lt;File&gt; getResources() {
  ...<span class="fragment dimcode"><br/>  public void deleteFiles() {<br/></span>  ...</pre></div><aside class="notes"><p>Let's assume you've got a interface, resource service</p><p>and a class that implements it</p><p>maybe that class has a lot of other methods</p><p>that are weird</p></aside></section><section><pre class="fragment dimcode">class Ci3po {
  ...<span class="fragment dimcode"><br/>  public translate(FileFinder f) {<br/></span>    List&lt;File&gt; = f.getResources()
    ...
  }
}</pre><div class="fragment"> <p><em>tightly coupled inputs through</em></p><p><em>overly specific implementation</em></p></div><aside class="notes">Now I'm locked into creating a FileFinder,
if it has a lot of extra scope, I don't
want to have to build that state.
Let me pass in what you'll use!</aside></section><section><p>I would have to extend a real implementation.</p><pre class="fragment dimcode">ci3po.translate(new FileFinder() {...});</pre></section><section><pre class="fragment dimcode">class Ci3po {
  ...
  public translate(ResourceService f) {<span class="fragment dimcode"><br/>    if (f instanceof FileFinder) {<br/></span>      List&lt;File&gt; files = (FileFinder) f.getResources()
      ...
    }
  }
}</pre><div class="fragment"> <p><em>tightly coupled inputs through</em></p><p><em>closed for extension code</em></p></div><aside class="notes">I'm STILL locked into creating a FileFinder,
because you are using instanceof</aside></section><section><div class="fragment"><h2>instanceof only on datatypes</h2><p class="fragment">further reading: scala case classes</p><!-- TODO: add matcher here--><!-- TODO: fully grep this--><aside class="notes">because: if its not immutable data, can ask it to solve problem
for you.</aside></div></section><section><p>Ci3po: Translations as a service</p><pre class="fragment dimcode">class Ci3po {
 <span class="fragment dimcode"><br/>  Uploader uploader;<br/></span> 
  public translate(ResourceService f) {
    ...
  }
}</pre><aside class="notes">Ok, now let's say Ci3po has an uploader it uses</aside></section><section><pre class="fragment dimcode">class Ci3po {
 
  Uploader uploader;
 
  public translate(ResourceService f) {<span class="fragment dimcode"><br/>    uploader.setEndpoint('http://ci/translations')
    uploader.sendGet(
       new HttpGet('hasTranslations', 
       params(f.getFiles()))<br/></span>    ...
  }
}</pre><div class="fragment"> <p><em>tightly coupled inputs through</em></p><p><em>reaching into state</em></p></div><aside class="notes">Translator calls into an uploader, instead of asking it
if it has translations, it makes a request, coupling to httpclient</aside></section><section><p>better</p><pre class="fragment dimcode"> uploader.hasTranslations(files)</pre></section>