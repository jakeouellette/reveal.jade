include mixins.jade
+slide
  p Part 2) Cohesion:
  p How to limit objects' scope
  p How to limit objects' responsibilities
+readyslide
  +codeexample
    p
      | class R2D3 {
      |   public visualize() {
      |     ...
      |   }
      | }
  +notes.
    Let's talk about R2D3.
    We said it visualizes resources using d3
    a javascript framework
+readyslide
  +codeexample
    p
      | class R2D3 {
      | 
      +revealedcodeblock
        |   public visualize(String projectRoot) {
        |     List&lt;File&gt; resources = getResources(projectRoot)
        |     // Visualizer code
        |   }
      | 
      +revealedcodeblock
        |   private List&lt;File&gt; getResources(String projectRoot) {
        |     ...
        |   }
      | }
  div.fragment 
    p
      em Multiple-responsibility
    ol
      li.fragment visualizer
      li.fragment resource-getter
  +notes
    p so this visualize task
    p calls this getResources method
+slide
  p getResources(...): Tightly coupled to visualize(...)
  p.fragment getResources(...): Difficult to mock
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    | PowerMock
    +revealedcodeblock
      |   .createPartialMock(
      |     R2D3.class, 
      |     "getResources")
      |   .andReturn(files);
    | 
  +notes.
    To change the behavior in unit test, you'd have to mock this get resources
    method.
+slide
  p Powermock requires looking at internals
  img(src='resources/c3po_naked.jpg', height='400', class='noborder')
  +notes.
      a hidden collaborator
+slide
  p Implies an iceberg
  img(src='resources/iceberg.jpg', height='400', class='noborder')
  +notes.
    The need to powermock implies a tight coupling on internal behavior, not
    a single responsibility
    Not taking advantage of OO facilities to separate behaviors
+readyslide
  p `Extends`: The same, but more hidden
  +codeexample
    +codeblock
      | class R2D3 extends FileFinder {
    | 
    |   public visualize(String projectRoot) {
    +codeblock
      |     List&lt;File&gt; resources = getResources(projectRoot)
    |     // Visualizer code
    |   }
    | }
  div.fragment 
    ul
      li.fragment extends is evil (Holub)
      li.fragment single responsibility (Fowler)
      li.fragment open/closed (Fowler)
      li.fragment Class does too much (Google Testability)
  +notes.
    the problem is this method is tightly coupled
    to this class's implementation of get resources
+readyslide
  +codeexample
    | 
    | PowerMock
    +revealedcodeblock
      |    .createPartialMock(
      |      FileFinder.class, 
      |      "getResources")
      |    .andReturn(files);
    | 
  +notes.
    Still need to mock out the behavior in test, and
    if that internal class references something mock-worthy, but it, itself, isnt,
    then you get into tree-hierarchy searches that are complicated
+slide
  p Hard to Swap
  img(src='resources/swap_board.gif', height='500', class='noborder')
  +notes.
    hard to change behaviors, hard to swap out
+readyslide
  div.row
    div.column
      +codeexample
        | class R2D3 {
        |   List&lt;File&gt; files;
        | 
        +codeblock
          |   R2d3(String projectRoot) {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |   }
        | 
        |   public visualize() {
        |     ...
        |   }
        | }
    div.column
      ul
        li.fragment open/closed (Fowler)
        li.fragment Constructors do real work (Google Testability)
        li.fragment single responsibility? (Fowler)
  +notes
    p OK, we can extract FileFinder out
    p create it ahead of time in our constructor
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    | expectNew(FileFinder.class, "projectRoot")
    |   .andReturn(files);
    | 
  +notes.
    Now, in order to change the behavior you have to mock out internals.
+slide
  h2 avoid new in constructors
  p.fragment dependency inversion
  +notes.
    // TODO: motivate
+readyslide
  p ok, no new in my constructor!!!1
  +codeexample
    | class R2D3 {
    |   List&lt;File&gt; files;
    | 
    |   R2d3(String projectRoot) {
    +codeblock
      |     files = FileFinder.getResources(projectRoot)
    |   }
    | }
  ul
    li.fragment open/closed (Fowler)
    li.fragment Has Singletons(Google Testability)
    li.fragment single responsibility? (Fowler)
  +notes.
    OK
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    |  PowerMock
    +revealedcodeblock
      |    .mockStaticPartial(
      |      FileFinder.class, 
      |      "getResources");
      |  EasyMock.expect(
      |    FileFinder.getResources(...))
      |  .andReturn(files);
    | 
  +notes.
    Still mocking internals
+slide
  p When do statics improve code?
  p.fragment.dimafter no this
  p.fragment.dimafter pure functions
  p.fragment.dimafter Still is coupling
  +notes.
    Avoid bleeding local scope. Handy for pure functions, good no intent to override
+readyslide
  +codeexample
    | class R2D4 extends R2D3 {
    | 
    |   @override
    |   public List&lt;File&gt; getResources()
  +notes.
    One of the nice things about statics is they prevent inheritance
    from being used to replace collaborator behaviors
+readyslide
  p perfect code
  +codeexample
    | class R2D3 {
    |   final List&lt;File&gt; files;
    | 
    +codeblock
      |   R2d3(List&lt;File&gt; visualizableFiles) {
      |     this.files = visualizableFiles;
      |   }
    | 
    +codeblock
      |   public visualize() {
      |     // visualization code
      |   }
    | }
  +notes.
    A good pattern is to separate
    out the concerns and JUST pass in the files
    you might also inject it into the
    visualize method depending on how it works
+readyslide
  p static factories are better than nothing
  +codeexample
    p
      | class R2D3 {
      |   List&lt;File&gt; files;
      | 
      +revealedcodeblock
        |   public static R2D3 create(String projectRoot) {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |     return new R2D3(files)
        |   }
      | 
      +codeblock
        |   R2d3(List&lt;File&gt; visualizableFiles) {
        |     this.files = visualizableFiles;
        |   }
      |   ...
      | }
  +notes.
    You can make incremental refactorings that
    get you closer to ideal. Better than passing
    factories everywhere
+readyslide
  p Static factory can be pulled out into a provider later.
  +codeexample
    p
      | class R2D3Provider implements Provider&lt;R2D3&gt; {
      |   @Inject String projectRoot
      | 
      +revealedcodeblock
        |   public static R2D3 provide() {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |     return new R2D3(files)
      |   }
+readyslide
  p Ci3po: the translator
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate() {
    |     ...
    |   }
    | }
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate(TaskContainer t) {
    +codeblock
      |     List&lt;File&gt; files = t
      |       .getByPath(:app:fileFinder")
      |       .fileFinder
      |       .getResources();
    |     ...
    |   }
    | }
  ul
    li.fragment.dimafter Reaching into collaborators (Google Testability)
    li.fragment.dimafter Interface Segregation (Fowler)
    li.fragment single responsibility? (Fowler)
  +notes.
    This is tightly coupled, to mock it:
+slide
  p Annoying to mock.
+readyslide
  +codeexample
    |     Ci3po.translate(new TaskContainer() {
    +codeblock
      |       public getByPath(String s) {
    |         return resourceService
    |       }
    +codeblock
      |       ... (40 more lines of code)
    |     })
  +notes.
    If we want to mock just the internal service, we have to
    mock the full api, including the 40-some odd methods that are unused
+slide
  p Easier: Just pass the right thing in!
+readyslide
  +codeexample
    |     Ci3po.translate(resourceService.getResources())
  +hiddenheader
    p If we're both objects:
    p Don't do things to my data.
    p Ask me to do things.
  p.fragment.replaceafter Law of demeter
+readyslide
  +hiddenheader
    p Law of demeter: 
  p.fragment Tell a dog to walk:
  p.fragment Don't tell the dog's legs to walk.
  p.fragment Tell the dog.
+slide
  p A method may only call things in direct scope
+readyslide
  p It can call a method of it's own class
  +codeexample
    | this.draw()
+readyslide
  p Or methods of objects injected in
  +codeexample
    | graphics.draw()
+readyslide
  p Or methods of objects it made
  +codeexample
    | local = new Gif()
    | local.draw()
+readyslide
  p Or methods of objects in it's class
  +codeexample
    | this.helper.draw()
+slide
  p But it should avoid reaching into other classes
  +codeexample
    | this.helper.getPainter.draw()
+slide
  p This creates couplings:
  p Now it depends on both the helper and the painter's code not changing.
+slide
  p If you can do it anyway, why am I doing it for you?
+slide
  p Law of demeter is about #[em behavior] of objects
+readyslide
  +hiddenheader A lot of data is hierarchical
  +revealedcodeexample
    | "person": [
    |   "head": [ "hair": "brown", "eyes": "blue" ], 
    |   "legs": 2]
+readyslide
  +hiddenheader Can be encoded as objects
  +revealedcodeexample
    | person = new Person(
    |   new Head(new Hair("brown"), new Eyes("blue")), 
    |   new Legs(2), ...)
+readyslide
  +hiddenheader Does this violate law of demeter?
  +revealedcodeexample
    | person.getHair().getColor()
+slide
  p Here, person is just data
  p.fragment just an immutable data-structure
+readyslide
  +hiddenheader Higher level data makes simpler parameter lists
  +revealedcodeexample
    | public class PersonPainter implements Drawable {
    |   public PersonPainter(Person p)
  +revealedcodeexample
    | public class PersonPainter implements Drawable {
    |   public PersonPainter(Hair h, Legs l, ...)
  +notes. 
    One benefit of immutable abstractions is it makes
    parameter lists simpler
+readyslide
  p Bad: Getting data from objects.
  +codeexample
    | public class View {
    |   public void paint() {
    |     if (personPainter
    +codeblock
      |       .getPerson().hair().equals("brown") {
    |       // Vary paint style
    |     }
  +notes.
    What happens when a higher level class reaches into
    a bheavior object's inner state?
+readyslide
  +codeexample
    | interface ResourceService
    |   public List&lt;File&gt; getResources()
  p vs
  div.fragment
    +codeexample
      | interface ResourceService
      |   public List&lt;File&gt; getResources()
      |   public void delete()
      |   public File find(String path)
  +notes.
    if a class doesn't need elements of an interface
      let's not make it more complex because of them
+readyslide
  p Inevitably:
  +codeexample
    | class YourResourceService extends ResourceService
    |   public delete() {
    |     throw new UnsupportedOperationException("nooo!")
    |   }
    |   ...
  div.fragment
    p
      em tight coupled inputs through
    p
      em extreme liskov substitution
+slide
  p High cohesion: Avoid unneeded scope.
+readyslide
  +codeexample
    | interface ResourceService
    |   public List&lt;File&gt; getResources()
  div.fragment
    +codeexample
      | class FileFinder
      |   public List&lt;File&gt; getResources() {
      |   ...
      +codeblock
        |   public void deleteFiles() {
      |   ...
  +notes
    p Let's assume you've got a interface, resource service
    p and a class that implements it
    p maybe that class has a lot of other methods
    p that are weird
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    +codeblock
      |   public translate(FileFinder f) {
    |     List&lt;File&gt; = f.getResources()
    |     ...
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em overly specific implementation
  +notes.
    Now I'm locked into creating a FileFinder,
    if it has a lot of extra scope, I don't
    want to have to build that state.
    Let me pass in what you'll use!
+readyslide
  p I would have to extend a real implementation.
  +codeexample
    | ci3po.translate(new FileFinder() {...});
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate(ResourceService f) {
    +codeblock
      |     if (f instanceof FileFinder) {
    |       List&lt;File&gt; files = (FileFinder) f.getResources()
    |       ...
    |     }
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em closed for extension code
  +notes.
    I'm STILL locked into creating a FileFinder,
    because you are using instanceof
+slide
  h2 instanceof only on datatypes
  p.fragment further reading: scala case classes
  // TODO: add matcher here
  // TODO: fully grep this
  +notes.
    because: if its not immutable data, can ask it to solve problem
    for you.
+readyslide
  p Ci3po: Translations as a service
  +codeexample
    | class Ci3po {
    | 
    +codeblock
      |   Uploader uploader;
    | 
    |   public translate(ResourceService f) {
    |     ...
    |   }
    | }
  +notes.
    Ok, now let's say Ci3po has an uploader it uses
+readyslide
  +codeexample
    | class Ci3po {
    | 
    |   Uploader uploader;
    | 
    |   public translate(ResourceService f) {
    +codeblock
      |     uploader.setEndpoint('http://ci/translations')
      |     uploader.sendGet(
      |        new HttpGet('hasTranslations', 
      |        params(f.getFiles()))
    |     ...
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em reaching into state
  +notes.
    Translator calls into an uploader, instead of asking it
    if it has translations, it makes a request, coupling to httpclient
+readyslide
  p better
  +codeexample
    |  uploader.hasTranslations(files)