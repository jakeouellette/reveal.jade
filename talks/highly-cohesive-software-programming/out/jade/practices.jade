include mixins.jade
+slide
  p Part 2) Cohesion:
  p Objects should have a single responsibility
  p Objects can't see what they don't need
+readyslide
  +codeexample
    p
      | class R2D3 {
      |   public visualize() {
      |     ...
      |   }
      | }
  +notes.
    Let's talk about R2D3.
    We said it visualizes resources using d3
    a javascript framework
+readyslide
  +codeexample
    p
      | class R2D3 {
      | 
      +revealedcodeblock
        |   public visualize(String projectRoot) {
        |     List&lt;File&gt; resources = getResources(projectRoot)
        |     // Visualizer code
        |   }
      | 
      +revealedcodeblock
        |   private List&lt;File&gt; getResources(String projectRoot) {
        |     ...
        |   }
      | }
  div.fragment 
    p
      em Multiple-responsibility
    ol
      li.fragment visualizer
      li.fragment resource-getter
  +notes
    p so this visualize task
    p calls this getResources method
+slide
  p getResources(...): Tightly coupled to visualize(...)
  p.fragment getResources(...): Difficult to mock
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    | PowerMock
    +revealedcodeblock
      |   .createPartialMock(
      |     R2D3.class, 
      |     "getResources")
      |   .andReturn(files);
    | 
  +notes.
    To change the behavior in unit test, you'd have to mock this get resources
    method.
+slide
  p Powermock requires looking at internals
  img(src='resources/c3po_naked.jpg', height='400', class='noborder')
  +notes.
      a hidden collaborator
+slide
  p Implies an iceberg
  img(src='resources/iceberg.jpg', height='400', class='noborder')
  +notes.
    The need to powermock implies a tight coupling on internal behavior, not
    a single responsibility
    Not taking advantage of OO facilities to separate behaviors
+readyslide
  p `Extends`: The same, but more hidden
  +codeexample
    +codeblock
      | class R2D3 extends FileFinder {
    | 
    |   public visualize(String projectRoot) {
    +codeblock
      |     List&lt;File&gt; resources = getResources(projectRoot)
    |     // Visualizer code
    |   }
    | }
  div.fragment 
    ul
      li.fragment extends is evil (Holub)
      li.fragment single responsibility (Fowler)
      li.fragment open/closed (Fowler)
      li.fragment Class does too much (Google Testability)
  +notes.
    the problem is this method is tightly coupled
    to this class's implementation of get resources
+readyslide
  +codeexample
    | 
    | PowerMock
    +revealedcodeblock
      |    .createPartialMock(
      |      FileFinder.class, 
      |      "getResources")
      |    .andReturn(files);
    | 
  +notes.
    Still need to mock out the behavior in test, and
    if that internal class references something mock-worthy, but it, itself, isnt,
    then you get into tree-hierarchy searches that are complicated
+slide
  p Hard to Swap
  img(src='resources/swap_board.gif', height='500', class='noborder')
  +notes.
    hard to change behaviors, hard to swap out
+readyslide
  div.row
    div.column
      +codeexample
        | class R2D3 {
        |   List&lt;File&gt; files;
        | 
        +codeblock
          |   R2d3(String projectRoot) {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |   }
        | 
        |   public visualize() {
        |     ...
        |   }
        | }
    div.column
      ul
        li.fragment single responsibility (Fowler)
        li.fragment open/closed (Fowler)
        li.fragment Constructors do real work (Google Testability)
  +notes
    p OK, we can extract FileFinder out
    p create it ahead of time in our constructor
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    | expectNew(FileFinder.class, "projectRoot")
    |   .andReturn(files);
    | 
  +notes.
    Now, in order to change the behavior you have to mock out internals.
+slide
  h2 avoid new in constructors
  p.fragment dependency inversion
  +notes.
    // TODO: motivate
+readyslide
  p ok, no new in my constructor!!!1
  +codeexample
    p
      | class R2D3 {
      |   List&lt;File&gt; files;
      | 
      |   R2d3(String projectRoot) {
      +codeblock
        |     files = FileFinder.getResources(projectRoot)
      |   }
      | }
  div.fragment 
    p
      em multiple-responsibility through 
    p 
      em Singleton / global coupling
  +notes.
    OK
+readyslide
  p Testing requires knowledge of internals :(
  +codeexample
    | 
    |  PowerMock.mockStaticPartial(
    |    FileFinder.class, "getResources");
    |  EasyMock.expect(FileFinder.getResources(...))
    |    .andReturn(files);
    | 
  +notes.
    Still mocking internals
+slide
  p When do statics improve code?
  p.fragment.dimafter no this
  p.fragment.dimafter pure functions
  p.fragment.dimafter Still is coupling
  +notes.
    Avoid bleeding local scope. Handy for pure functions, good no intent to override
+readyslide
  +codeexample
    | class R2D4 extends R2D3 {
    | 
    |   @override
    |   public List&lt;File&gt; getResources()
  +notes.
    One of the nice things about statics is they prevent inheritance
    from being used to replace collaborator behaviors
+readyslide
  p perfect code
  +codeexample
    | class R2D3 {
    |   final List&lt;File&gt; files;
    | 
    +codeblock
      |   R2d3(List&lt;File&gt; visualizableFiles) {
      |     this.files = visualizableFiles;
      |   }
    | 
    +codeblock
      |   public visualize() {
      |     // visualization code
      |   }
    | }
  +notes.
    A good pattern is to separate
    out the concerns and JUST pass in the files
    you might also inject it into the
    visualize method depending on how it works
+readyslide
  p static factories are better than nothing
  +codeexample
    p
      | class R2D3 {
      |   List&lt;File&gt; files;
      | 
      +codeblock
        |   public static R2D3 create(String projectRoot) {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |     return new R2D3(files)
        |   }
      | 
      +codeblock
        |   R2d3(List&lt;File&gt; visualizableFiles) {
        |     this.files = visualizableFiles;
        |   }
      |   ...
      | }
  +notes.
    You can make incremental refactorings that
    get you closer to ideal. Better than passing
    factories everywhere
+readyslide
  p Static factory can be pulled out into a provider later.
  +codeexample
    p
      | class R2D3Provider implements Provider&lt;R2D3&gt; {
      |   @Inject String projectRoot
      | 
      +codeblock
        |   public static R2D3 provide() {
        |     ResourceService finder = 
        |       new FileFinder(projectRoot)
        |     files = finder.getResources()
        |     return new R2D3(files)
      |   }
+slide
  p so that's 'single responsibility'
+readyslide
  p Ci3po: the translator
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate() {
    |     ...
    |   }
    | }
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate(TaskContainer t) {
    +codeblock
      |     List&lt;File&gt; files = t
      |       .getByPath(:app:fileFinder")
      |       .fileFinder
      |       .getResources();
    |     ...
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs
  +notes.
    This is tightly coupled, to mock it:
+slide
  p Annoying to mock.
+readyslide
  +codeexample
    |     Ci3po.translate(new TaskContainer() {
    +codeblock
      |       public getByPath(String s) {
    |         return resourceService
    |       }
    +codeblock
      |       ... (40 more lines of code)
    |     })
  +notes.
    If we want to mock just the internal service, we have to
    mock the full api, including the 40-some odd methods that are unused
+slide
  p Easier: Just pass the right thing in!
+readyslide
  +codeexample
    |     Ci3po.translate(resourceService.getResources())
+slide
  p Single responsibility: Smaller interfaces
  // TODO: better image
  img(src='resources/confused_1.gif', height='500', class='noborder')
  +notes.
    The cognitive load to understand mirrors the actual API usage
+readyslide
  +codeexample
    | interface ResourceService
    |   public List&lt;File&gt; getResources()
  p vs
  div.fragment
    +codeexample
      | interface ResourceService
      |   public List&lt;File&gt; getResources()
      |   public void delete()
      |   public File find(String path)
  +notes.
    if a class doesn't need elements of an interface
      let's not make it more complex because of them
+readyslide
  p Inevitably:
  +codeexample
    | class YourResourceService extends ResourceService
    |   public delete() {
    |     throw new UnsupportedOperationException("nooo!")
    |   }
    |   ...
  div.fragment
    p
      em tight coupled inputs through
    p
      em extreme liskov substitution
+slide
  p High cohesion: Avoid unneeded scope.
+readyslide
  +codeexample
    | interface ResourceService
    |   public List&lt;File&gt; getResources()
  div.fragment
    +codeexample
      | class FileFinder
      |   public List&lt;File&gt; getResources() {
      |   ...
      +codeblock
        |   public void deleteFiles() {
      |   ...
  +notes
    p Let's assume you've got a interface, resource service
    p and a class that implements it
    p maybe that class has a lot of other methods
    p that are weird
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    +codeblock
      |   public translate(FileFinder f) {
    |     List&lt;File&gt; = f.getResources()
    |     ...
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em overly specific implementation
  +notes.
    Now I'm locked into creating a FileFinder,
    if it has a lot of extra scope, I don't
    want to have to build that state.
    Let me pass in what you'll use!
+readyslide
  p I would have to extend a real implementation.
  +codeexample
    | ci3po.translate(new FileFinder() {...});
+readyslide
  +codeexample
    | class Ci3po {
    |   ...
    |   public translate(ResourceService f) {
    +codeblock
      |     if (f instanceof FileFinder) {
    |       List&lt;File&gt; files = (FileFinder) f.getResources()
    |       ...
    |     }
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em closed for extension code
  +notes.
    I'm STILL locked into creating a FileFinder,
    because you are using instanceof
+slide
  h2 instanceof only on datatypes
  p.fragment further reading: scala case classes
  // TODO: add matcher here
  // TODO: fully grep this
  +notes.
    because: if its not immutable data, can ask it to solve problem
    for you.
+readyslide
  p Ci3po: Translations as a service
  +codeexample
    | class Ci3po {
    | 
    +codeblock
      |   Uploader uploader;
    | 
    |   public translate(ResourceService f) {
    |     ...
    |   }
    | }
  +notes.
    Ok, now let's say Ci3po has an uploader it uses
+readyslide
  +codeexample
    | class Ci3po {
    | 
    |   Uploader uploader;
    | 
    |   public translate(ResourceService f) {
    +codeblock
      |     uploader.setEndpoint('http://ci/translations')
      |     uploader.sendGet(
      |        new HttpGet('hasTranslations', 
      |        params(f.getFiles()))
    |     ...
    |   }
    | }
  div.fragment 
    p
      em tightly coupled inputs through
    p
      em reaching into state
  +notes.
    Translator calls into an uploader, instead of asking it
    if it has translations, it makes a request, coupling to httpclient
+readyslide
  p better
  +codeexample
    |  uploader.hasTranslations(files)