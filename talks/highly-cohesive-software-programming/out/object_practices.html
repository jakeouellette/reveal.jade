<section><div class="fragment dimafter visiblestart"><p>Objects:</p><p>Don't do things to my data, ask me to do things.</p></div><p class="fragment replaceafter">Law of demeter</p><p class="fragment">Principle of Least Surprise</p></section><section><div class="fragment dimafter visiblestart"><p>Law of demeter: </p></div><p class="fragment">Tell a dog to walk:</p><p class="fragment">Don't tell the dog's legs to walk.</p><p class="fragment">Tell the dog.</p></section><section><div class="fragment"><p>A method may only call things in direct scope</p></div></section><section><div class="fragment"><p>So let's say this circle represents an object with a method</p><img src="resources/lod_1.png" height="300" class="noborder"/></div></section><section><p>It can call a method of it's own class</p><img src="resources/lod_2.png" height="300" class="noborder"/><pre class="fragment dimcode">this.draw()</pre></section><section><p>Or methods of objects injected in</p><img src="resources/lod_4.png" height="300" class="noborder"/><pre class="fragment dimcode">graphics.draw()</pre></section><section><p>Or methods of objects it made</p><img src="resources/lod_5.png" height="300" class="noborder"/><pre class="fragment dimcode">local = new Gif()
local.draw()</pre></section><section><p>Or methods of objects in it's class</p><img src="resources/lod_3.png" height="300" class="noborder"/><pre class="fragment dimcode">this.helper.draw()</pre></section><section><div class="fragment"><p>If you can do it anyway, why am I doing it for you?</p></div></section><section><div class="fragment"><p>Law of demeter is about <em>behavior</em> of objects</p></div></section><section><div class="fragment dimafter visiblestart">A lot of data is hierarchical</div><pre class="fragment hiddencode dimcode">"person": [
  "head": [ "hair": "brown", "eyes": "blue" ], 
  "legs": 2]</pre></section><section><div class="fragment dimafter visiblestart">Can be encoded as objects</div><pre class="fragment hiddencode dimcode">person = new Person(
  new Head(new Hair("brown"), new Eyes("blue")), 
  new Legs(2), ...)</pre></section><section><div class="fragment dimafter visiblestart">Does this violate law of demeter?</div><pre class="fragment hiddencode dimcode">person.hair.color</pre></section><section><div class="fragment"><p>Here, person is just data</p><p class="fragment">just an immutable data-structure</p></div></section><section><div class="fragment dimafter visiblestart">Higher level data makes simpler parameter lists</div><pre class="fragment hiddencode dimcode">public class PersonPainter implements Drawable {
  public PersonPainter(Person p)</pre><pre class="fragment hiddencode dimcode">public class PersonPainter implements Drawable {
  public PersonPainter(Hair h, Legs l, ...)</pre><aside class="notes">One benefit of immutable abstractions is it makes
parameter lists simpler</aside></section><section><p>Bad: Getting data from objects.</p><pre class="fragment dimcode">public class View {
  public void paint() {
    if (personPainter<span class="fragment dimcode"><br/>      .getPerson().hair().equals("brown") {<br/></span>      // Vary paint style
    }</pre><aside class="notes">What happens when a higher level class reaches into
a bheavior object's inner state?</aside></section><section><div class="fragment"><p>"Object Oriented" programming </p><p>in contrast with "functional" programming</p></div></section><section><div class="fragment dimafter visiblestart">Let's say you've got a couple of classes</div><pre class="fragment hiddencode dimcode">public class PersonPainter implements Drawable {
  public void draw(Graphics g) {
     ...
  }</pre><pre class="fragment hiddencode dimcode">public class DogPainter implements Drawable {
  public void draw(Graphics g) {
     ...
  }</pre></section><section><div class="fragment"><p>New classes for same behaviors through extends</p><div style="background:#fff;"><img src="resources/new_class.gif" height="150" class="noborder"/></div></div></section><section><div class="fragment dimafter visiblestart">Let's say you want to add a behavior</div><pre class="fragment hiddencode dimcode"> interface Drawable {
   public void draw(Graphics g);<span class="fragment dimcode hiddencode"><br/>   public void drawOutline(Graphics g);<br/></span> }</pre></section><section><pre class="fragment dimcode">public class PersonPainter implements Drawable {
  public void draw(Graphics g) {
     ...
  }
 <span class="fragment dimcode"><br/> 
  public void drawOutline(Graphics g) {
     ...<br/></span></pre></section><section><div class="fragment"><div style="background:#fff;"><img src="resources/new_function.gif" height="150" class="noborder"/></div></div></section><section><div class="fragment"><p>Could pull "Painting" behavior into single class:</p><pre class="fragment hiddencode dimcode">public class Painter {
 
  public void draw(Object o) {
    if (o instanceof Person) {
      ...
    }
  }<span class="fragment dimcode hiddencode"><br/>  public void drawOutline(Object o) {
    if (o instanceof Person) {
      ...
    }<br/></span>    ...
  }</pre></div></section><section><p>But then, the only way to extend types is to add to every behavior</p><pre class="fragment dimcode">public class Painter {
 
  public drawOutline(Object o) {
    if (o instanceof Person) {
      ...
    }<span class="fragment dimcode hiddencode"><br/>    if (o instanceof Dog) {
      ...
    }<br/></span><span class="fragment dimcode hiddencode"><br/>    if (o instanceof Cat) {
      ...
    }<br/></span>    ...</pre></section><section><div class="fragment"><div style="background:#fff;"><img src="resources/new_class.gif" height="300" class="noborder"/></div></div></section><section><div class="fragment"><p>There are solutions</p><div style="background:#fff;" class="fragment"><p>Clojure Protocols</p><img src="resources/protocols.gif" height="300" class="noborder"/></div></div></section><section><div class="fragment"><p>PersonPainter, who paints the person: Object</p><p>Person, who is painted by a painter: data</p></div></section><section><p>AVOID mixing concepts:</p><pre class="fragment dimcode">public class PersonPainter implements Drawable {
  public void draw(Graphics g) {
    ...
  }
  
  public Color getHair() {</pre></section><section><div class="fragment"><p>So that's Object Orientation</p></div></section>