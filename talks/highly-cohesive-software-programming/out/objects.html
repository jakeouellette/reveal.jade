<section><div class="fragment"><div class="galaxy"><div class="fall"><p><i>Episode I</i></p><p>What is an object anyway</p></div></div></div></section><section><div class="fragment"><p>William Cook's definition of "Object Oriented"</p><img class="noborder" src="resources/william_cook.jpg" width="300"/></div></section><section><div class="fragment"><p>Object Oriented Programming:</p><p>Often misunderstood as "just using classes for stuff"</p><img class="fragment noborder" src="resources/droids_looking_for.jpg"/><p class="fragment">Not Object Oriented.</p></div></section><section><p>Many schools start out with something like this</p><pre class="fragment dimcode">class Point {
  final int x, y

  public int getX() { return x }
  ...</pre></section><section><p>Lisp</p><pre class="fragment dimcode">
(lambda () x)
</pre><div class="fragment"><p>Java 8</p><pre class="fragment dimcode">(() -&gt; x)</pre></div><div class="fragment"><p>C</p><pre class="fragment dimcode">
point-&gt;x
</pre></div><aside class="notes">Not too different from a lambda function in a functional language</aside></section><section><p>Classes can have state, is that OO?</p><pre class="fragment dimcode">class Point {
  int x, y

  public void setX(int x) { this.x = x }
  ...</pre><aside class="notes">Easily represent as a struct in a lower order language
If no mutation</aside></section><section><p>Classes are not necessary to `set` state</p><p></p><p>(C Language)</p><pre class="fragment dimcode">point-&gt;x = 5</pre><div class="fragment"><p>Nor is Mutation necessary to have classes</p><pre class="fragment dimcode">class Point {
  int x, y

  public Point setX(int newX) {
    new Point(newX, y)
  }
  ...</pre></div></section><section><pre class="fragment dimcode">class IntPoint implements Point {
  int x, y

  public int getX() { return x }
  ...</pre><aside class="notes">Ok, what about when you start representing abstractions?</aside></section><section><pre class="fragment dimcode">class DoublePoint implements Point {
  double x, y

  public int getX() { return (int)x }
  ...</pre><aside class="notes">Now you can use the same APIs with different underlying representation</aside></section><section><div class="fragment"><p>Isn't this just data?</p><aside class="notes">is that really a good example though? In this case it's just
data that is varying, not behavior</aside></div></section><section><pre class="fragment dimcode">class Image implements Drawable {
  int currentFrame = ...

  public void draw(Graphics g) { ... }
    ...</pre><aside class="notes">Let's use a behavioral abstraction</aside></section><section><pre class="fragment dimcode">class Gif implements Drawable {
  int currentFrame = ...

  public void draw(Graphics g) { ... }
    ...</pre><aside class="notes">Now you can represent new abstractions</aside></section><section><div class="fragment"><p>An object is a first-class, dynamically dispatched behavior.</p><aside class="notes">http://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html?m=1
dynamic dispatch in C: http://www.cs.rit.edu/~ats/books/ooc.pdf
http://lwn.net/Articles/444910/</aside></div></section><section><div class="fragment"><p>Dynamic dispatch is sometimes called</p><ul><li class="fragment dimafter">"message passing"</li><li class="fragment dimafter">"late binding"</li><li class="fragment dimafter">"dynamic binding"</li><li class="fragment dimafter">"polymorphism"</li></ul><aside class="notes">Polymorphism is what java devs are used to hearing</aside></div></section><section><div class="fragment"><p>Optional, but <strong>not essential:</strong></p><ol><li class="fragment">mutable state</li><li class="fragment">inheritance</li><li class="fragment">identity</li><li class="fragment">classes</li></ol></div></section><section><div class="fragment dimafter visiblestart"><p>Object Orientedness doesn't require:</p><p>1) mutable state</p></div><pre class="fragment hiddencode dimcode">class Gif implements Drawable {
  int currentFrame = ...
<span class="fragment dimcode"><br/>  public Pair&lt;Frame, Drawable&gt; draw() {<br/></span>   return new Pair(
     getFrame(),
     new Gif(currentFrame++));
  }
...</pre><aside class="notes">Compose a program of value objects, state changes
through creation of new objects
We can create the same Gif by returning
a frame of the image, no mutation required</aside></section><section><div class="fragment dimafter visiblestart"><p>Object Orientedness doesn't require:</p><p>2) inheritance</p></div><p class="fragment">Go: Interfaces are protocols</p><pre class="fragment hiddencode dimcode"> type Drawable interface {
   Draw()
 }</pre><p class="fragment"><em>Any object with "Draw()" is works</em></p><aside class="notes">composition can be isometric
Go: Dynamic dispatch
In java, inheritance is a means to achieve dispatch, so essential,
but extends is not:
Languages like go can define new protocols / interfaces
Existing types didn't inherit them explicitly.</aside></section><section><div class="fragment dimafter visiblestart"><p>Object Orientedness doesn't require:</p><p>3) `Identity`, e.g., ==</p></div><pre class="fragment hiddencode dimcode">a.id.equals(b.id)</pre><aside class="notes">Compare by reference
If this is needed for objects, can be added to specific implementation
if things are using this explicitly, it is tightly coupling and preventing
dynamic dispatch on equals, so may cause issues.</aside></section>