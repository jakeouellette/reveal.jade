include mixins.jade

+readyslide
  +hiddenheader
    p Objects:
    p Don't do things to my data, ask me to do things.
  p.fragment.replaceafter Law of demeter
  p.fragment Principle of Least Surprise
+readyslide
  +hiddenheader
    p Law of demeter: 
  p.fragment Tell a dog to walk:
  p.fragment Don't tell the dog's legs to walk.
  p.fragment Tell the dog.
+slide
  p A method may only call things in direct scope
+slide
  p So let's say this circle represents an object with a method
  img(src='resources/lod_1.png', height='300', class='noborder')
+readyslide
  p It can call a method of it's own class
  img(src='resources/lod_2.png', height='300', class='noborder')
  +codeexample
    | this.draw()
+readyslide
  p Or methods of objects injected in
  img(src='resources/lod_4.png', height='300', class='noborder')
  +codeexample
    | graphics.draw()
+readyslide
  p Or methods of objects it made
  img(src='resources/lod_5.png', height='300', class='noborder')
  +codeexample
    | local = new Gif()
    | local.draw()
+readyslide
  p Or methods of objects in it's class
  img(src='resources/lod_3.png', height='300', class='noborder')
  +codeexample
    | this.helper.draw()
+slide
  p If you can do it anyway, why am I doing it for you?
+slide
  p Law of demeter is about #[em behavior] of objects
+readyslide
  +hiddenheader A lot of data is hierarchical
  +revealedcodeexample
    | "person": [
    |   "head": [ "hair": "brown", "eyes": "blue" ], 
    |   "legs": 2]
+readyslide
  +hiddenheader Can be encoded as objects
  +revealedcodeexample
    | person = new Person(
    |   new Head(new Hair("brown"), new Eyes("blue")), 
    |   new Legs(2), ...)
+readyslide
  +hiddenheader Does this violate law of demeter?
  +revealedcodeexample
    | person.hair.color
+slide
  p Here, person is just data
  p.fragment just an immutable data-structure
+readyslide
  +hiddenheader Higher level data makes simpler parameter lists
  +revealedcodeexample
    | public class PersonPainter implements Drawable {
    |   public PersonPainter(Person p)
  +revealedcodeexample
    | public class PersonPainter implements Drawable {
    |   public PersonPainter(Hair h, Legs l, ...)
  +notes. 
    One benefit of immutable abstractions is it makes
    parameter lists simpler
+readyslide
  p Bad: Getting data from objects.
  +codeexample
    | public class View {
    |   public void paint() {
    |     if (personPainter
    +codeblock
      |       .getPerson().hair().equals("brown") {
    |       // Vary paint style
    |     }
  +notes.
    What happens when a higher level class reaches into
    a bheavior object's inner state?
+readyslide
  +hiddenheader With Inheritance: Easy to add new classes 
  +revealedcodeexample
    | public class PersonPainter implements Drawable {
    |   public void draw(Graphics g) {
    |      ...
    |   }
  +revealedcodeexample
    | public class DogPainter implements Drawable {
    |   public void draw(Graphics g) {
    |      ...
    |   }
+slide
  p New classes for same behaviors through extends
  div(style="background:#fff;")
    img(src='resources/new_class.gif', height='150', class='noborder')
+readyslide
  +hiddenheader Let's say you want to add a behavior
  +revealedcodeexample
    |  interface Drawable {
    |    public void draw(Graphics g);
    +revealedcodeblock
      |    public void drawOutline(Graphics g);
    |  }
+readyslide
  +codeexample
    | public class PersonPainter implements Drawable {
    |   public void draw(Graphics g) {
    |      ...
    |   }
    | 
    +codeblock
      | 
      |   public void drawOutline(Graphics g) {
      |      ...
+slide
  div(style="background:#fff;")
    img(src='resources/new_function.gif', height='150', class='noborder')
+readyslide
  p Could pull "Painting" behavior into single class:
  +codeexample
    | public class Painter {
    | 
    |   public void draw(Object o) {
    |     if (o instanceof Person) {
    |       ...
    |     }
    |     ...
    |   }
+readyslide
  +codeexample
    | public class Painter {
    | 
    |   public void draw(Object o) {
    |     if (o instanceof Person) {
    |       ...
    |     }
    |   }
    +codeblock
      |   public void drawOutline(Object o) {
    |     if (o instanceof Person) {
    |       ...
    |     }
    |     ...
    |   }
+readyslide
  p But then, the only way to extend types is to add to every behavior
  +codeexample
    | public class Painter {
    | 
    |   public drawOutline(Object o) {
    |     if (o instanceof Person) {
    |       ...
    |     }
    | 
    |     if (o instanceof Dog) {
    |       ...
    |     }
    +codeblock
      |     if (o instanceof Cat) {
      |       ...
      |     }
    |     ...
+slide
  div(style="background:#fff;")
    img(src='resources/new_class.gif', height='300', class='noborder')
+slide
  p this is known as the `expression problem`
+slide
  p There are solutions
  div.fragment(style="background:#fff;")
    p Clojure Protocols
    img(src='resources/protocols.gif', height='300', class='noborder')
+slide
  p Keep data safe: Don't conflate "Person" with "Painting a Person"
  p One is data, the other is behavior
+slide
  p Person was just data, wouldn't ask person to paint itself
+slide
  p In Java, must make the tradeoff between:
  ul
    li.fragment easy type extension
    li.fragment easy behavior extension 
+readyslide
  p AVOID mixing concepts:
  +codeexample
    | public class PersonPainter implements Drawable {
    |   public void draw(Graphics g) {
    |     ...
    |   }
    |   
    |   public Color getHair() {
+slide
  p So that's Object Orientation