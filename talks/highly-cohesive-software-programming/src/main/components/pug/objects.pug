include mixins.pug
+slide
  div.galaxy
    div.fall
      p
        i Episode I
      p What is an object anyway
+slide
  p William Cook's definition of "Object Oriented"
  img.noborder(src='resources/william_cook.jpg', width='300')
+slide
  p Object Oriented Programming:
  p Often misunderstood as "just using classes for stuff"
  img.fragment.noborder(src='resources/droids_looking_for.jpg')
  p.fragment Not Object Oriented.
+readyslide
  p Many schools start out with something like this
  +codeexample
    | class Point {
    |   final int x, y
    |
    |   public int getX() { return x }
    |   ...
+readyslide
  p Lisp
  +codeexample
    |
    | (lambda () x)
    |
  div.fragment
    p Java 8
    +codeexample
      | (() -&gt; x)
  div.fragment
    p C
    +codeexample
      |
      | point-&gt;x
      |
  +notes.
    Not too different from a lambda function in a functional language
+readyslide
  p Classes can have state, is that OO?
  +codeexample
    | class Point {
    |   int x, y
    |
    |   public void setX(int x) { this.x = x }
    |   ...
  +notes.
    Easily represent as a struct in a lower order language
    If no mutation
+readyslide
  p Classes are not necessary to `set` state
  p
  p (C Language)
  +codeexample
    | point-&gt;x = 5
  div.fragment
    p Nor is Mutation necessary to have classes
    +codeexample
      | class Point {
      |   int x, y
      |
      |   public Point setX(int newX) {
      |     new Point(newX, y)
      |   }
      |   ...
+readyslide
  +codeexample
    | class IntPoint implements Point {
    |   int x, y
    |
    |   public int getX() { return x }
    |   ...
  +notes.
    Ok, what about when you start representing abstractions?
+readyslide
  +codeexample
    | class DoublePoint implements Point {
    |   double x, y
    |
    |   public int getX() { return (int)x }
    |   ...
  +notes.
    Now you can use the same APIs with different underlying representation
+slide
  p Isn't this just data?
  +notes.
    is that really a good example though? In this case it's just
    data that is varying, not behavior
+readyslide
  +codeexample
    | class Image implements Drawable {
    |   int currentFrame = ...
    |
    |   public void draw(Graphics g) { ... }
    |     ...
  +notes.
    Let's use a behavioral abstraction
+readyslide
  +codeexample
    | class Gif implements Drawable {
    |   int currentFrame = ...
    |
    |   public void draw(Graphics g) { ... }
    |     ...
  +notes.
    Now you can represent new abstractions
+slide
  p An object is a first-class, dynamically dispatched behavior.
  +notes.
    http://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html?m=1
    dynamic dispatch in C: http://www.cs.rit.edu/~ats/books/ooc.pdf
    http://lwn.net/Articles/444910/
+slide
  p Dynamic dispatch is sometimes called
  ul
    li.fragment.dimafter "message passing"
    li.fragment.dimafter "late binding"
    li.fragment.dimafter "dynamic binding"
    li.fragment.dimafter "polymorphism"
  +notes.
    Polymorphism is what java devs are used to hearing
+slide
  p Optional, but #[strong not essential:]
  ol
    li.fragment mutable state
    li.fragment inheritance
    li.fragment identity
    li.fragment classes
+readyslide
  +hiddenheader
    p Object Orientedness doesn't require:
    p 1) mutable state
  +revealedcodeexample
    | class Gif implements Drawable {
    |   int currentFrame = ...
    |
    +codeblock
      |   public Pair&lt;Frame, Drawable&gt; draw() {
    |    return new Pair(
    |      getFrame(),
    |      new Gif(currentFrame++));
    |   }
    | ...
  +notes.
    Compose a program of value objects, state changes
    through creation of new objects
    We can create the same Gif by returning
    a frame of the image, no mutation required
+readyslide
  +hiddenheader
    p Object Orientedness doesn't require:
    p 2) inheritance
  p.fragment Go: Interfaces are protocols
  +revealedcodeexample
    |  type Drawable interface {
    |    Draw()
    |  }
  p.fragment
    em Any object with "Draw()" is works
  +notes.
    composition can be isometric
    Go: Dynamic dispatch
    In java, inheritance is a means to achieve dispatch, so essential,
    but extends is not:
    Languages like go can define new protocols / interfaces
    Existing types didn't inherit them explicitly.
//- +slide
//-   +codeexample
//-     |  interface Drawable {
//-     |    public void draw(Graphics g);
//-     |  }
//- +slide
//-   p Inherits interface, can be used as type:
//-   +codeexample
//-     |  public class Gif implements Drawable {
//-     |    public void draw(Graphics g) {
//-     |
//- +slide
//-   p Does not inherit interface, can't be used
//-   +codeexample
//-     |  public class Artist {
//-     |    public void draw(Graphics g);
//-     |
//-   +notes.
//-     Artist doesn't extend the interface, so can't be used.
//-     You could wrap this artist, but there's a lot of downsides there
+readyslide
  +hiddenheader
    p Object Orientedness doesn't require:
    p 3) `Identity`, e.g., ==
  +revealedcodeexample
    | a.id.equals(b.id)
  +notes.
    Compare by reference
    If this is needed for objects, can be added to specific implementation
    if things are using this explicitly, it is tightly coupling and preventing
    dynamic dispatch on equals, so may cause issues.
